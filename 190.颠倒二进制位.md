# 190.颠倒二进制位
## 颠倒给定的 32 位无符号整数的二进制位。
    示例：
    输入: 00000010100101000001111010011100
    输出: 00111001011110000010100101000000
    解释: 输入的二进制串 00000010100101000001111010011100表示无符号整数 43261596，
    因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
思路：emmmmm一开始能想到的肯定就是逆序遍历然后输出（哦对 它不能算作数组，是个字符串呀，那还要思考一下，反正就好像不是太好遍历。

```c++
//整数翻转
int y = 0; // y用来承接翻转后的整数
        while (x != 0) {
            if (y > 214748364 || y < -214748364) return 0; // 溢出，那么输出为0(这是题目要求)
            y = y * 10 + x % 10; // y在变化的同时x也在变化，效率高
            // x % 10的目的是得到个位的数值
            x = x / 10;   // x / 10相当于“右移移位运算”，是地板除。
        }
        return y; // 得到结果
```
然后因为上面这个兄弟写整数反转的模板，他进而就得出了二进制翻转的情况，emmmmm我觉得还挺奇妙的，反正比其他的解法中移来移去要容易看懂。
```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        long res = 0; // 要用long，int会溢出
        for (int i = 0; i < 32; i++) { // 这一步和LC7——整数翻转的思路相同
        // 这里使用for循环而不是while，原因是本题要求32位整数，位数是固定的！
            res = res * 2 + n % 2; // 10进制乘上10，模10；二进制改成2即可
            n = n / 2; // 从十进制的10改成2即可
        }
        return res; // 返回结果
    }
};
```
然后还有一个思路 我觉得我也可以接受<br/>但是我感觉要对二进制理解比较深
```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t ans = 0;
        int i = 32;
        while(i--){
            ans<<=1;
            ans+=n&1;
            n>>=1;
        }
        return ans;
    }
};
```
然后还有的方法就是分治的方法emmmmm我感觉容易想到，但是实现起来的时候我不是太理解



